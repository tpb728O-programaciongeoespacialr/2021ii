{
  "articles": [
    {
      "path": "about.html",
      "title": "About this site",
      "description": "Some additional details about the website",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-11T00:36:16-06:00"
    },
    {
      "path": "index.html",
      "title": "TPB728O Programación de aplicaciones geoespaciales en R 2021-II",
      "description": "Curso TPB728O Programación de aplicaciones geoespaciales en R. Maestría en Sistemas de Información Geográfica y Teledetección. Universidad de Costa Rica (UCR) y Universidad Nacional (UNA).\n",
      "author": [
        {
          "name": "Manuel Vargas",
          "url": "https://github.com/mfvargas"
        }
      ],
      "contents": "\r\n\r\nContents\r\nDescripción\r\nPrograma\r\nLecciones\r\nRecursos\r\n\r\nDescripción\r\nEste es un curso sobre desarrollo de aplicaciones geoespaciales en el lenguaje de programación R. Forma parte de la Maestría en Sistemas de Información Geográfica y Teledetección de la Universidad de Costa Rica (UCR) y de la Universidad Nacional (UNA).\r\nSe estudian los fundamentos del lenguaje R, sus bibliotecas geoespaciales y sus capacidades para generar gráficos estadísticos. El enfoque del curso es teórico-práctico, con lecciones teóricas combinadas con ejercicios de programación en los cuales los estudiantes aplicarán en diversos escenarios de procesamiento de datos los conocimientos adquiridos.\r\nEste sitio web corresponde al curso impartido durante el segundo ciclo lectivo de 2021. Para ver las versiones de otros ciclos lectivos, puede visitar el sitio web general del curso.\r\nPrograma\r\nPrograma del curso\r\nLecciones\r\n01 R - Conceptos básicos (RStudio, funciones predefinidas, tipos de datos)02 R - Conceptos básicos (definición de funciones, condicionales, ciclos)03 R Markdown\r\nRecursos\r\nRecursos adicionales a la bibliografía del curso\r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-25T11:42:24-06:00"
    },
    {
      "path": "leccion-01-r-conceptosbasicos.html",
      "title": "R - Conceptos básicos",
      "author": [],
      "contents": "\r\n\r\nContents\r\nResumen\r\nTrabajo previo\r\nCaracterísticas generales de R\r\nEl ambiente de desarrollo RStudio\r\nFunciones\r\nEjemplos\r\nArgumentos\r\nAyuda\r\nConjuntos de datos para pruebas\r\n\r\nPaquetes\r\nTipos de datos\r\nTipos básicos\r\nNúmeros\r\nCaracteres\r\nLógicos\r\nVectores\r\nDefinición\r\nIndexación\r\nOperaciones\r\n\r\nMatrices\r\nDefinición\r\nIndexación\r\nOperaciones\r\n\r\n\r\nTipos compuestos\r\nFactores\r\nDefinición\r\nOperaciones\r\n\r\nData Frames\r\nDefinición\r\nIndexación\r\nOperaciones\r\n\r\n\r\nOtros\r\nFechas\r\nOperaciones\r\n\r\n\r\n\r\n\r\nResumen\r\nEn esta lección, se estudiarán los conceptos básicos del lenguaje de programación R, incluyendo:\r\nCaracterísticas generales de R.\r\nEl ambiente de desarrollo RStudio.\r\nFunciones y paquetes.\r\nTipos de datos.\r\nTrabajo previo\r\nInstale R y RStudio en su computadora. Puede aceptar las opciones que los programas instaladores le presentan por defecto. Si lo desea, puede ver los siguientes videos que muestran detalladamente el proceso de instalación en los sistemas operativos Windows, macOS y Linux (Ubuntu).\r\nInstale el sistema para control de versiones Git.\r\nLea los capítulos del 1 al 12 de Grolemund, G., & Wickham, H. (2014). Hands-On Programming with R.\r\nCaracterísticas generales de R\r\nR es un lenguaje de programación enfocado en análisis estadístico. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como biomedicina, bioinformática y finanzas, entre muchos otros. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993.\r\nAlgunas de las principales características de este lenguaje son:\r\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\r\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\r\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables solo pueden tener un tipo de datos.\r\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\r\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\r\nPara programar en R, puede utilizarse una interfaz de línea de comandos y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio.\r\nEl ambiente de desarrollo RStudio\r\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de RStudio Cloud.\r\n\r\nInterfaz de RStudio.\r\nAdemás de edición de código fuente en R (y otros lenguajes), RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\r\nFunciones\r\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático y, por lo general, retorna un valor como salida. Todas las funciones tienen un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,).\r\nEjemplos\r\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\r\n\r\n\r\n# Impresión de una hilera de caracteres\r\nprint(\"Hola mundo\")\r\n\r\n\r\n[1] \"Hola mundo\"\r\n\r\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\r\n\r\n\r\n# Media aritmética\r\nmean(c(2, 4, 5, 9))\r\n\r\n\r\n[1] 5\r\n\r\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\r\n\r\n\r\n# Impresión del directorio de trabajo\r\ngetwd()\r\n\r\n\r\n[1] \"C:/Users/mfvargas/tpb728O-programaciongeoespacialr/2021ii\"\r\n\r\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\r\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\r\n\r\n\r\n# Definición del directorio de trabajo (la ruta debe existir)\r\nsetwd(\"C:/Users/mfvargas\")\r\n\r\n# Directorio con espacios, tildes y eñes\r\nsetwd(\"C:/Users/mfvargas/mi directorio con espacios y tildes áéíóúñ\")\r\n\r\n\r\n\r\n Ejercicio:\r\na. Obtenga la ruta de su directorio de trabajo con la función getwd().\r\nb. Si lo desea, cambie la ruta de su directorio de trabajo con la función setwd(). Verifique el cambio con getwd().\r\nArgumentos\r\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario. En algunos casos, el orden y el tipo de datos de los argumentos permiten que el interpretador de R conozca cuál es cada uno.\r\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot() para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\r\n\r\n\r\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\r\nplot(\r\n  x=cars, \r\n  xlab=\"Velocidad (mph)\", \r\n  ylab=\"Distancia requerida para frenar (pies)\"\r\n)\r\n\r\n\r\n\r\n\r\n Ejercicio: estudie la documentación de la función plot() y agregue al gráfico anterior:\r\na. Un título.\r\nb. Un subtítulo.\r\nAyuda\r\nPara obtener ayuda de una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\r\n\r\n\r\n# Ayuda de la función setwd()\r\n?setwd\r\nhelp(setwd)\r\n\r\n\r\n\r\nAdicionalmente, puede utilizarse la función apropos() para buscar funciones por palabras clave.\r\n\r\n\r\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\r\napropos(\"mean\")\r\n\r\n\r\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \r\n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\r\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\r\n\r\nLa función example() presenta ejemplos sobre el uso de una función.\r\n\r\n\r\n# Ejemplos de uso de la función mean()\r\nexample(\"mean\")\r\n\r\n\r\n\r\nmean> x <- c(0:10, 50)\r\n\r\nmean> xm <- mean(x)\r\n\r\nmean> c(xm, mean(x, trim = 0.10))\r\n[1] 8.75 5.50\r\n\r\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R. También puede obtenerse ayuda sobre una función en los buscadores de Internet (ej. Google), además de ejemplos, tutoriales y otros materiales de apoyo.\r\nConjuntos de datos para pruebas\r\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\r\n\r\n\r\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\r\ndata()\r\n\r\n# Información sobre el cojunto de datos \"cars\"\r\n?cars\r\n\r\n# Información sobre el cojunto de datos \"Iris\"\r\n?iris\r\n\r\n\r\n\r\nPaquetes\r\nLas funciones de R se distribuyen mediante paquetes. Cada paquete contiene un conjunto de funciones y estructuras de datos relacionadas entre sí. Para utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\r\n\r\n\r\n# Carga del paquete stats\r\nlibrary(stats)\r\n\r\n\r\n\r\nAlgunos paquetes están contenidos en la distribución base de R y otros deben instalarse de manera separada con la función install.packages().\r\nEn el siguiente ejemplo, se instala el paquete PASWR2, el cual contiene el conjunto de datos TITANIC3.\r\n\r\n\r\n# Instalación del paquete PASWR2 (note las comillas)\r\ninstall.packages(\"PASWR2\")\r\n\r\n\r\n\r\nEl paquete PASWR2 se carga con library().\r\n\r\n\r\n# Carga de PASWR2\r\nlibrary(PASWR2)\r\n\r\n\r\n\r\nEl conjunto de datos TITANIC3 puede visualizarse con la función View().\r\n\r\n\r\n# Visualización del conjunto de datos TITANIC3\r\nView(TITANIC3)\r\n\r\n\r\n\r\nPara visualizar gráficamente el conjunto de datos, el siguiente gráfico de barras muestra la distribución de pasajeros por clase.\r\n\r\n\r\n# Cantidades de pasajeros por clase\r\ntable(TITANIC3$pclass)\r\n\r\n\r\n\r\n1st 2nd 3rd \r\n323 277 709 \r\n\r\n\r\n# Gráfico de barras por clase de pasajero\r\nbarplot(\r\n  height=table(TITANIC3$pclass),\r\n  main=\"Distribución de pasajeros del Titanic por clase\",\r\n  xlab = \"Clase\",\r\n  ylab = \"Cantidad de pasajeros\"  \r\n)\r\n\r\n\r\n\r\n\r\nLa distribución por cada clase puede dividirse en fallecidos y sobrevivientes.\r\n\r\n\r\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\r\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\r\ntable(TITANIC3$survived, TITANIC3$pclass)\r\n\r\n\r\n   \r\n    1st 2nd 3rd\r\n  0 123 158 528\r\n  1 200 119 181\r\n\r\nEl siguiente gráfico muestra en un gráfico de barras apiladas la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\r\n\r\n\r\n# Gráfico de barras apiladas\r\nbarplot(\r\n  height = table(TITANIC3$survived, TITANIC3$pclass),\r\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\r\n  xlab = \"Clase\",\r\n  ylab = \"Cantidad de pasajeros\",\r\n  col = topo.colors(2)\r\n)\r\n\r\n# Leyenda\r\nlegend(\r\n  x = \"topleft\",\r\n  inset = 0.03,\r\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\r\n  fill = topo.colors(2),\r\n  horiz = TRUE\r\n)\r\n\r\n\r\n\r\n\r\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas.\r\n\r\n\r\n# Gráfico de barras agrupadas\r\nbarplot(\r\n  height = table(TITANIC3$survived, TITANIC3$pclass),\r\n  main = \"Distribución de pasajeros fallecidos y sobrevivientes por clase\",\r\n  xlab = \"Clase\",\r\n  ylab = \"Cantidad de pasajeros\",  \r\n  col = topo.colors(2),\r\n  beside = TRUE\r\n)\r\n\r\n# Leyenda\r\nlegend(\r\n  x = \"topleft\",\r\n  inset = 0.03,\r\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\r\n  fill = topo.colors(2),\r\n  horiz = TRUE\r\n)\r\n\r\n\r\n\r\n\r\n Ejercicio:\r\na. Muestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\r\nb. Muestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\r\nTipos de datos\r\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\r\nR proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz.\r\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y <- (o ->). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\r\n\r\n\r\n# Número\r\nx <- 10\r\nx\r\n\r\n\r\n[1] 10\r\n\r\n\r\n# Otro número\r\n20 -> y\r\ny\r\n\r\n\r\n[1] 20\r\n\r\n\r\n# Hilera de caracteres\r\nnombre <- 'Manuel'\r\nnombre\r\n\r\n\r\n[1] \"Manuel\"\r\n\r\n\r\n# Vector de hileras de caracteres\r\ndias <- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\r\ndias\r\n\r\n\r\n[1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"   \r\n[6] \"Viernes\"   \"Sábado\"   \r\n\r\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\r\nEl tipo de una variable puede consultarse con la función typeof(). Por ejemplo:\r\n\r\n\r\ntypeof(x)\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(y)\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(nombre)\r\n\r\n\r\n[1] \"character\"\r\n\r\ntypeof(dias)\r\n\r\n\r\n[1] \"character\"\r\n\r\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\r\nTipos básicos\r\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\r\nNúmeros\r\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\r\n\r\n\r\n# Declaración de variables numéricas\r\nx <- 5\r\ny <- 0.5\r\n\r\n# Suma\r\nx + y\r\n\r\n\r\n[1] 5.5\r\n\r\n\r\n# Tipos de datos numéricos\r\ntypeof(x)\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(y)\r\n\r\n\r\n[1] \"double\"\r\n\r\ntypeof(x + y)\r\n\r\n\r\n[1] \"double\"\r\n\r\nPara declarar números enteros puede usarse el sufijo L o la función as.integer().\r\n\r\n\r\n# Números enteros\r\nx <- 10L\r\ny <- as.integer(15)\r\n\r\n# Multiplicación\r\nx * y\r\n\r\n\r\n[1] 150\r\n\r\n\r\n# Tipos de datos enteros\r\ntypeof(x)\r\n\r\n\r\n[1] \"integer\"\r\n\r\ntypeof(y)\r\n\r\n\r\n[1] \"integer\"\r\n\r\ntypeof(x * y)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\r\nCaracteres\r\nSe utilizan para representar textos. Deben estar encerrados entre comillas simples ('') o dobles (\"\").\r\n\r\n\r\n# Hileras de caracteres\r\nnombre <- \"María\"\r\napellido <- \"Pérez\"\r\n\r\n# Concatenación mediante la función paste()\r\npaste(nombre, apellido)\r\n\r\n\r\n[1] \"María Pérez\"\r\n\r\nLógicos\r\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\r\n\r\n\r\n# Variable lógica\r\na <- 1 < 2\r\na\r\n\r\n\r\n[1] TRUE\r\n\r\n\r\n# Variable lógica\r\nb <- 1 > 2\r\nb\r\n\r\n\r\n[1] FALSE\r\n\r\nLas expresiones lógicas pueden combinarse con operadores como:\r\n& (Y, en inglés AND)\r\n| (O, en inglés OR)\r\n! (NO, en inglés NOT)\r\n\r\n\r\n# Operador lógico AND\r\n(1 < 2) & (3 < 4)\r\n\r\n\r\n[1] TRUE\r\n\r\n\r\n# Operador lógico OR\r\n(2 + 2 == 5) | (20 <= 10)\r\n\r\n\r\n[1] FALSE\r\n\r\n\r\n# Operador lógico NOT\r\n!(2 + 2 == 5)\r\n\r\n\r\n[1] TRUE\r\n\r\nVectores\r\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\r\nDefinición\r\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\r\n\r\n\r\n# Definición de un vector de números\r\nvector_numeros <- c(1, 7, 32, 45, 57)\r\nvector_numeros\r\n\r\n\r\n[1]  1  7 32 45 57\r\n\r\n\r\n# Definición de un vector de hileras de caracteres\r\nvector_nombres <- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\r\nvector_nombres\r\n\r\n\r\n[1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\r\n\r\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia:\r\n\r\n\r\n# Definición de un vector de números con la secuencia de 1 a 10\r\nvector_secuencia <- 1:10\r\nvector_secuencia\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n\r\n# Definición de un vector de números con la secuencia de -5 a 5\r\nvector_secuencia <- -5:5\r\nvector_secuencia\r\n\r\n\r\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\r\n\r\n\r\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\r\nvector_secuencia <- -0.5:3.7\r\nvector_secuencia\r\n\r\n\r\n[1] -0.5  0.5  1.5  2.5  3.5\r\n\r\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\r\n\r\n\r\n# Definición de un vector de números con la secuencia de 1 a 10\r\nvector_secuencia <- seq(1, 10)\r\nvector_secuencia\r\n\r\n\r\n [1]  1  2  3  4  5  6  7  8  9 10\r\n\r\n\r\n# Definición de un vector de números con la secuencia de 0.5 a 15.3, con incremento de 2\r\nvector_secuencia <- seq(from=0.5, to=15.3, by=2)\r\nvector_secuencia\r\n\r\n\r\n[1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\r\n\r\n\r\n# Definición de un vector de números con la secuencia de 1.5 a 9.4, con longitud de 4\r\nvector_secuencia <- seq(from=1.5, to=9.4, length.out=4)\r\nvector_secuencia\r\n\r\n\r\n[1] 1.500000 4.133333 6.766667 9.400000\r\n\r\nIndexación\r\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\r\n\r\n\r\n# Vector de nombres de países\r\npaises <- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\r\npaises\r\n\r\n\r\n[1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"   \r\n\r\n\r\n# Elemento en el índice 3\r\npaises[3]\r\n\r\n\r\n[1] \"China\"\r\n\r\nEl operador : puede utilizarse para especificar un rango de índices:\r\n\r\n\r\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\r\npaises[2:4]\r\n\r\n\r\n[1] \"Francia\"   \"China\"     \"Australia\"\r\n\r\nCon la función c(), es posible especificar un conjunto de índices particulares:\r\n\r\n\r\n# Elementos entre los índices 1, 4 y 5\r\npaises[c(1, 4, 5)]\r\n\r\n\r\n[1] \"Argentina\" \"Australia\" \"México\"   \r\n\r\nLos números negativos pueden usarse para excluir índices:\r\n\r\n\r\n# Exclusión de los índices 3 y 4\r\npaises[c(-3, -4)]\r\n\r\n\r\n[1] \"Argentina\" \"Francia\"   \"México\"   \r\n\r\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\r\n\r\n\r\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\r\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\r\n\r\n\r\n[1] \"Argentina\" \"Francia\"   \"Australia\"\r\n\r\nOperaciones\r\nEn los vectores pueden aplicarse operaciones aritméticas:\r\n\r\n\r\na <- c(1, 3, 5, 7)\r\nb <- c(2, 4, 6, 8)\r\n\r\n# Suma de vectores\r\na + b\r\n\r\n\r\n[1]  3  7 11 15\r\n\r\n\r\n# Multiplicación de vectores\r\na * b\r\n\r\n\r\n[1]  2 12 30 56\r\n\r\nY también pueden realizarse operaciones relacionales:\r\n\r\n\r\n# Comparación con el operador <\r\na < b\r\n\r\n\r\n[1] TRUE TRUE TRUE TRUE\r\n\r\nMatrices\r\nUna matriz es una estructura bidimensional de filas y columnas.\r\nDefinición\r\nLas matrices se definen mediante la función matrix().\r\n\r\n\r\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\r\nm <- matrix(1:9, nrow=3, ncol=3)\r\nm\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    4    7\r\n[2,]    2    5    8\r\n[3,]    3    6    9\r\n\r\n\r\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\r\nm <- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\r\nm\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    2    3\r\n[2,]    4    5    6\r\n[3,]    7    8    9\r\n\r\n\r\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\r\ndatos <- c(18, 500, 25, 1000, 30, 2000)\r\nfilas <- c(\"Ana\", \"Mario\", \"Laura\")\r\ncolumnas <- c(\"Edad\", \"Salario\")\r\n\r\nm <- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\r\nm\r\n\r\n\r\n      Edad Salario\r\nAna     18     500\r\nMario   25    1000\r\nLaura   30    2000\r\n\r\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\r\nIndexación\r\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\r\n\r\n\r\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\r\nm[2, 2]\r\n\r\n\r\n[1] 1000\r\n\r\n\r\n# Elementos de la primera fila\r\nm[1,]\r\n\r\n\r\n   Edad Salario \r\n     18     500 \r\n\r\n\r\n# Elementos de la segunda columna\r\nm[, 2]\r\n\r\n\r\n  Ana Mario Laura \r\n  500  1000  2000 \r\n\r\n\r\n# Elementos de las filas 1 y 2\r\nm[1:2, ]\r\n\r\n\r\n      Edad Salario\r\nAna     18     500\r\nMario   25    1000\r\n\r\n\r\n# Elementos de la fila \"Mario\"\r\nm[\"Mario\", ]\r\n\r\n\r\n   Edad Salario \r\n     25    1000 \r\n\r\n\r\n# Elementos de la columna \"Salario\"\r\nm[, \"Salario\"]\r\n\r\n\r\n  Ana Mario Laura \r\n  500  1000  2000 \r\n\r\nOperaciones\r\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\r\n\r\n\r\na <- matrix(1:4, nrow=2, ncol=2)\r\na\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    3\r\n[2,]    2    4\r\n\r\n\r\nb <- matrix(5:8, nrow=2, ncol=2)\r\nb\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    5    7\r\n[2,]    6    8\r\n\r\n\r\n# Suma de matrices\r\na + b\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    6   10\r\n[2,]    8   12\r\n\r\n\r\n# Multiplicación de matrices\r\na * b\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    5   21\r\n[2,]   12   32\r\n\r\n\r\n# Comparación de matrices con el operador >\r\na > b\r\n\r\n\r\n      [,1]  [,2]\r\n[1,] FALSE FALSE\r\n[2,] FALSE FALSE\r\n\r\nTipos compuestos\r\nFactores\r\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\r\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\r\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\r\nDefinición\r\nUn factor se crea con la función factor().\r\n\r\n\r\n# Factor de valores de sexo\r\nsexo <- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\r\n\r\n\r\n\r\nOperaciones\r\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\r\n\r\n\r\n# Etiquetas de los niveles\r\nlevels(sexo)\r\n\r\n\r\n[1] \"Femenino\"  \"Masculino\"\r\n\r\n\r\n# Cantidad de niveles\r\nnlevels(sexo)\r\n\r\n\r\n[1] 2\r\n\r\n\r\n# Conteo de elementos de cada uno de los niveles del factor\r\ntable(sexo)\r\n\r\n\r\nsexo\r\n Femenino Masculino \r\n        2         2 \r\n\r\nData Frames\r\nLos data frames son estructuras bidimensionales compuestas por varios vectores, de manera similar a una matriz. Por lo general, las filas de la matriz corresponden a observaciones (o cases) y las columnas a variables. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o la tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\r\nDefinición\r\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\r\n\r\n\r\n# Vector de nombres de países\r\npaises <- c(\"PAN\", \"CRI\", \"NIC\", \"SLV\", \"HND\", \"GTM\", \"BLZ\", \"DOM\")\r\n\r\n# Vector de cantidades de habitantes de cada país (en millones)\r\npoblaciones <- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3, 10.6)\r\n\r\n# Creación de un data frame a partir de los dos vectores\r\npoblaciones_paises <- \r\n  data.frame(\r\n    pais = paises, \r\n    poblacion = poblaciones\r\n  )\r\n\r\n# Impresión del data frame\r\npoblaciones_paises\r\n\r\n\r\n  pais poblacion\r\n1  PAN       4.1\r\n2  CRI       5.0\r\n3  NIC       6.2\r\n4  SLV       6.4\r\n5  HND       9.2\r\n6  GTM      16.9\r\n7  BLZ       0.3\r\n8  DOM      10.6\r\n\r\nIndexación\r\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\r\n\r\n\r\n# Fila 1\r\npoblaciones_paises[1, ]\r\n\r\n\r\n  pais poblacion\r\n1  PAN       4.1\r\n\r\n\r\n# Filas 1, 5 y 7\r\npoblaciones_paises[c(1, 5, 7), ]\r\n\r\n\r\n  pais poblacion\r\n1  PAN       4.1\r\n5  HND       9.2\r\n7  BLZ       0.3\r\n\r\n\r\n# Columna 2\r\npoblaciones_paises[, 2]\r\n\r\n\r\n[1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3 10.6\r\n\r\n\r\n# Fila 1, columna 2\r\npoblaciones_paises[1, 2]\r\n\r\n\r\n[1] 4.1\r\n\r\n\r\n# Filas 1:4, columna 2\r\npoblaciones_paises[1:4, 2]\r\n\r\n\r\n[1] 4.1 5.0 6.2 6.4\r\n\r\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\r\n\r\n\r\n# Columna de nombres de países\r\npoblaciones_paises$pais\r\n\r\n\r\n[1] \"PAN\" \"CRI\" \"NIC\" \"SLV\" \"HND\" \"GTM\" \"BLZ\" \"DOM\"\r\n\r\n\r\n# Modificación de los valores de toda una columna\r\npoblaciones_paises$poblacion = poblaciones_paises$poblacion*2\r\npoblaciones_paises\r\n\r\n\r\n  pais poblacion\r\n1  PAN       8.2\r\n2  CRI      10.0\r\n3  NIC      12.4\r\n4  SLV      12.8\r\n5  HND      18.4\r\n6  GTM      33.8\r\n7  BLZ       0.6\r\n8  DOM      21.2\r\n\r\nOperaciones\r\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\r\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\r\n\r\n\r\n# Lectura de archivo CSV ubicado en la Web\r\ncovid <- \r\n  read.csv(\"https://raw.githubusercontent.com/tpb728O-programaciongeoespacialr/2021ii/main/datos/cepredenac/covid/04_22_21_CSV_GENERAL_CENTROAMERICA.csv\")\r\n\r\ncovid\r\n\r\n\r\n  pais fallecidos recuperados activos positivos\r\n1  PAN       6198      351949    3845    361992\r\n2  CRI       3125      199779   32370    235274\r\n3  GTM       7345      194075   16725    218145\r\n4  HND       4981       77020  121358    203359\r\n5  SLV       2089       64208    1864     68161\r\n6  BLZ        318       12164     114     12596\r\n7  NIC        181        5212      57      5450\r\n\r\n Ejercicio:\r\na. Descargue el archivo del ejemplo anterior (https://raw.githubusercontent.com/tpb728O-programaciongeoespacialr/2021ii/main/datos/cepredenac/covid/04_22_21_CSV_GENERAL_CENTROAMERICA.csv) en su computadora y cárguelo en otro data frame mediante read.csv(). \r\nLa función str() despliega la estructura de un objeto R.\r\n\r\n\r\n# Estructura del data frame\r\nstr(poblaciones_paises)\r\n\r\n\r\n'data.frame':   8 obs. of  2 variables:\r\n $ pais     : chr  \"PAN\" \"CRI\" \"NIC\" \"SLV\" ...\r\n $ poblacion: num  8.2 10 12.4 12.8 18.4 33.8 0.6 21.2\r\n\r\nLa función summary() proporciona un resumen de los contenidos de un data frame:\r\n\r\n\r\n# Resumen de los contenidos del data frame\r\nsummary(poblaciones_paises)\r\n\r\n\r\n     pais             poblacion    \r\n Length:8           Min.   : 0.60  \r\n Class :character   1st Qu.: 9.55  \r\n Mode  :character   Median :12.60  \r\n                    Mean   :14.68  \r\n                    3rd Qu.:19.10  \r\n                    Max.   :33.80  \r\n\r\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\r\n\r\n\r\n# Vista de los casos de COVID-19\r\nView(covid, \"Casos de COVID-19 en Centramérica\")\r\n\r\n\r\n\r\nOtros\r\nFechas\r\nLas fecha se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, las fechas en R se almacenan como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\r\nOperaciones\r\nLa función Sys.Date() retorna la fecha actual.\r\n\r\n\r\n# Fecha actual\r\nfecha_actual <- Sys.Date()\r\nfecha_actual\r\n\r\n\r\n[1] \"2021-08-11\"\r\n\r\n\r\n# Tipo de datos\r\ntypeof(fecha_actual)\r\n\r\n\r\n[1] \"double\"\r\n\r\n\r\n# Clase\r\nclass(fecha_actual)\r\n\r\n\r\n[1] \"Date\"\r\n\r\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato.\r\n\r\n\r\n# Conversión de fecha en formato año-mes-día\r\nfecha_caracter_01 <- \"2020-01-01\"\r\nfecha_01 <- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\r\nfecha_01\r\n\r\n\r\n[1] \"2020-01-01\"\r\n\r\n\r\n# Conversión de fecha en formato día/mes/año\r\nfecha_caracter_02 <- \"31/01/2020\"\r\nfecha_02 <- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\r\nfecha_02\r\n\r\n\r\n[1] \"2020-01-31\"\r\n\r\n\r\n# Diferencia entre fechas\r\nfecha_02 - fecha_01\r\n\r\n\r\nTime difference of 30 days\r\n\r\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-11T21:23:37-06:00"
    },
    {
      "path": "leccion-02-r-conceptosbasicos.html",
      "title": "R - Conceptos básicos",
      "author": [],
      "contents": "\r\n\r\nContents\r\nResumen\r\nDefinición de funciones\r\nCondicionales\r\nLa sentencia if\r\nLa claúsula else\r\nLa cláusula else if\r\n\r\nCiclos\r\nSentencias básicas para manejo de ciclos\r\nLa sentencia for\r\nLa sentencia while\r\nLa sentencia repeat\r\nLas sentencias break y next\r\n\r\nLas funciones apply()\r\napply()\r\nlapply()\r\ntapply()\r\n\r\nVectorización\r\n\r\n\r\nResumen\r\nEn esta lección, se continúa el estudio de los conceptos básicos del lenguaje de programación R, incluyendo:\r\nDefinición de funciones.\r\nCondicionales.\r\nCiclos.\r\nDefinición de funciones\r\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\r\nToda función tiene tres partes esenciales:\r\nUn nombre.\r\nUn conjunto de argumentos.\r\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\r\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra función function().\r\n\r\n\r\nmi_funcion <- function(argumento_1, argumento_2, argumento_n) {\r\n  # Cuerpo de la función\r\n}\r\n\r\n\r\n\r\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los promedios de exámenes, proyectos y tareas.\r\n\r\n\r\nnota_final <- function(promedio_examenes,\r\n                       promedio_proyectos,\r\n                       promedio_tareas) {\r\n  factor_examenes <- promedio_examenes * 0.5\r\n  factor_proyectos <- promedio_proyectos * 0.4\r\n  factor_tareas <- promedio_tareas * 0.1\r\n  \r\n  return(factor_examenes + factor_proyectos + factor_tareas)\r\n}\r\n\r\n\r\n\r\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\r\nAhora que está definida, la función nota_final() puede ser invocada, con diferentes argumentos:\r\n\r\n\r\n# Si ni se incluyen los nombres de los argumentos, la función asume que se ingresan en el mismo orden en el que fueron definidos\r\nnota_final(100, 50, 0)\r\n\r\n\r\n[1] 70\r\n\r\n\r\n# El uso de los nombres de argumentos permite modificar su orden\r\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\r\n\r\n\r\n[1] 70\r\n\r\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\r\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\r\n\r\n\r\nnota_final <- function(promedio_examenes,\r\n                       promedio_proyectos = 0,\r\n                       promedio_tareas = 0) {\r\n  factor_examenes <- promedio_examenes * 0.5\r\n  factor_proyectos <- promedio_proyectos * 0.4\r\n  factor_tareas <- promedio_tareas * 0.1\r\n  \r\n  # Al no llamarse a la función return(), se retorna la última expresión:\r\n  factor_examenes + factor_proyectos + factor_tareas\r\n}\r\n\r\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\r\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\r\n\r\n\r\n[1] 70\r\n\r\n\r\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\r\nnota_final(100, promedio_proyectos = 50)\r\n\r\n\r\n[1] 70\r\n\r\n Ejercicio:\r\na. Defina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\r\nb. Defina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\r\nc. Defina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros). \r\nCondicionales\r\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\r\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\r\nLa sentencia if\r\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\r\n\r\n\r\nif (condicion) {\r\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\r\n}\r\n\r\n\r\n\r\nPor ejemplo:\r\n\r\n\r\nedad <- 25\r\n\r\nif (edad >= 18) {\r\n  print(\"Adulto\")\r\n}\r\n\r\n\r\n[1] \"Adulto\"\r\n\r\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\r\nLa claúsula else\r\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\r\n\r\n\r\nedad <- 15\r\n\r\nif (edad >= 18) {\r\n  print(\"Adulto\")\r\n} else {\r\n  print(\"Menor\")\r\n}\r\n\r\n\r\n[1] \"Menor\"\r\n\r\nLa cláusula else if\r\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\r\n\r\n\r\nedad <- 70\r\n\r\nif (edad < 18) {\r\n  print(\"Menor\")\r\n} else if (edad < 65) {\r\n  print(\"Adulto\")\r\n} else {\r\n  print(\"Adulto mayor\")\r\n}\r\n\r\n\r\n[1] \"Adulto mayor\"\r\n\r\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\r\n Ejercicio:\r\na. Defina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de mapas corporal - Wikipedia. \r\nCiclos\r\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con cláusulas que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\r\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\r\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\r\nSentencias básicas para manejo de ciclos\r\nLa sentencia for\r\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración, el valor del elemento que está siendo procesado se almacena en una variable.\r\n\r\n\r\nfor (variable in vector) {\r\n  # bloque de instrucciones\r\n}\r\n\r\n\r\n\r\nPor ejemplo, el siguiente fragmento de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\r\n\r\n\r\nvector_nombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\r\n\r\nfor (nombre in vector_nombres) {\r\n  cat(\"Hola\", nombre, \"\\n\")\r\n}\r\n\r\n\r\nHola Andrés \r\nHola Beatriz \r\nHola Carlos \r\nHola Marta \r\nHola Pedro \r\nHola Sara \r\n\r\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\r\n\r\n\r\nvector_numeros <- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\r\n\r\nsuma <- 0\r\n\r\nfor (x in vector_numeros) {\r\n  suma <- suma + x\r\n}\r\n\r\ncat(\"Suma:\", suma)\r\n\r\n\r\nSuma: 140.95\r\n\r\n Ejercicio:\r\na. Utilice un ciclo for para recorrer el vector del ejemplo anterior y calcular el promedio de sus elementos. \r\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\r\n\r\n\r\nm <- matrix(1:12, nrow=3, ncol=4)\r\nm\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    4    7   10\r\n[2,]    2    5    8   11\r\n[3,]    3    6    9   12\r\n\r\n# Ciclo externo para recorrer las columnas de la matriz\r\nfor (j in 1:ncol(m)) {\r\n  suma_columna <- 0\r\n  # Ciclo interno para recorrer las elementos de cada columna\r\n  for (i in 1:nrow(m)) {\r\n    suma_columna <- suma_columna + m[i, j]\r\n  }\r\n  print(suma_columna)\r\n}\r\n\r\n\r\n[1] 6\r\n[1] 15\r\n[1] 24\r\n[1] 33\r\n\r\n Ejercicio:\r\na. Utilice dos ciclos for anidados para recorrer la matriz del ejemplo anterior y calcular el promedio de cada una de sus columnas. \r\nLa sentencia while\r\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración del ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\r\n\r\n\r\nwhile (condicion) {\r\n  # bloque de instrucciones \r\n}\r\n\r\n\r\n\r\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\r\n\r\n\r\n# Función para leer una respuesta desde la pantalla\r\nleer_respuesta <- function() {\r\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\r\n}\r\n\r\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\r\nwhile (leer_respuesta() != \"42\") {   \r\n  print(\"¡Su respuesta es incorrecta!\")\r\n}\r\n\r\n\r\n\r\n Ejercicio:\r\na. Utilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo. \r\nLa sentencia repeat\r\nLa sentencia repeat implementa un ciclo que se repite indefinidamente. Puede interrumpirse con una sentencia break.\r\n\r\n\r\nrepeat {\r\n  # bloque de instrucciones \r\n}\r\n\r\n\r\n\r\nLos ciclos repeat tienen una estructura más sencilla que los while. Algo que los diferencia es que los bloques de los ciclos repeat entran a ejecutarse al menos una vez.\r\nEn el siguiente ejemplo, se utiliza un ciclo repeat para implementar la pregunta y lectura de la respuesta que anteriormente se implementó con un ciclo while.\r\n\r\n\r\n# Función para leer una respuesta desde la pantalla\r\nleer_respuesta <- function() {\r\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\r\n}\r\n\r\n# Ciclo para imprimir la pregunta y leer la respuesta hasta que esta sea correcta\r\nrepeat {\r\n  respuesta <- leer_respuesta()\r\n  if (respuesta != \"42\") {\r\n    # Respuesta incorrecta\r\n    print(\"¡Su respuesta es incorrecta!\")\r\n  } else {\r\n    # Respuesta correcta. Se interrumpe el ciclo.\r\n    break\r\n  }\r\n}\r\n\r\n\r\n\r\nLas sentencias break y next\r\nLa sentencia break interrumpe un ciclo. La ejecución del programa continúa con la instrucción siguiente al bloque del ciclo.\r\nEn el siguiente ciclo for, se suman uno a uno los números de un vector, pero se usa un break para interrumpir el ciclo cuando el acumulado es mayor que 100.\r\n\r\n\r\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\r\n\r\nacumulado <- 0\r\n\r\nfor (x in vector_numeros) {\r\n  acumulado <- acumulado + x\r\n  cat(\"Acumulado:\", acumulado, \"\\n\")\r\n  if (acumulado >= 100) {\r\n    cat(\"Se superó el límite de 100 en el acumulado\")\r\n    break\r\n  }\r\n}\r\n\r\n\r\nAcumulado: 17 \r\nAcumulado: 40 \r\nAcumulado: 77 \r\nAcumulado: 118 \r\nSe superó el límite de 100 en el acumulado\r\n\r\nPor su parte, la sentencia next retorna el control al principio del bloque. Las instrucciones que hay después del next no se ejecutan. La siguiente iteración del ciclo (si la hay), se inicia entonces.\r\nEl siguiente ciclo recorre un vector de números. Se utiliza la sentencia next para “saltar” los números impares y sumar solo los pares.\r\n\r\n\r\nvector_numeros <- c(17, 23, 37, 41, 52, 64, 75)\r\n\r\nsuma_pares <- 0\r\n\r\nfor (x in vector_numeros) {\r\n  if (x %% 2 == 0) {\r\n    # Número par: se suma\r\n    suma_pares <- suma_pares + x\r\n  } else {\r\n    # Número impar: se \"salta\" al siguiente número\r\n    next\r\n  }\r\n}\r\n\r\ncat(\"Suma de los números pares:\", suma_pares)\r\n\r\n\r\nSuma de los números pares: 116\r\n\r\nLas funciones apply()\r\nEsta es una familia de funciones que manipulan subconjuntos de datos obtenidos a partir de matrices, listas y data frames, los cuales son recorridos de una forma repetitiva. Pueden funcionar como una alternativa a los ciclos y aplicar funciones en los subconjuntos de datos como, por ejemplo, funciones estadísticas en las columnas de una matriz o de un data frame. Su uso es muy recomendado por su eficiencia, flexibilidad y simplicidad.\r\nEntre estas funciones, pueden mencionarse apply(), lapply(), sapply(), vapply(), mapply(), rapply() y tapply().\r\napply()\r\nLa función apply() toma como entrada un arreglo o una matriz y aplica alguna función sobre sus filas o columnas.\r\nLa sintaxis de la función es:\r\n\r\n\r\napply(X, MARGIN, FUN, ...)\r\n\r\n\r\n\r\nEn donde:\r\n- X: es un arreglo o matriz.\r\n- MARGIN: MARGIN = 1 significa que la función actúa en las filas, MARGIN = 2 significa que la función actúa en las columnas y MARGIN = c(1, 2) significa que la función actúa en las filas y en las columnas.\r\n- FUN: es la función que se aplicará a cada uno de los elementos de X.\r\nEn el siguiente ejemplo, se utiliza la función apply() para sumar los elementos de las columnas de una matriz.\r\n\r\n\r\nm <- matrix(1:12, nrow=3, ncol=4)\r\nm\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    4    7   10\r\n[2,]    2    5    8   11\r\n[3,]    3    6    9   12\r\n\r\n# Suma de las columnas\r\napply(m, 2, sum)\r\n\r\n\r\n[1]  6 15 24 33\r\n\r\n Ejercicio:\r\na. Utilice la función apply() para obtener el promedio de los elementos de cada columna de la matriz del ejemplo anterior. \r\nlapply()\r\nLa función lapply() toma como entrada un vector o lista y retorna una lista de la misma longitud en la que cada uno de sus elementos es el resultado de aplicar una función al vector o lista de entrada.\r\nLa sintaxis de la función es:\r\n\r\n\r\nlapply(X, FUN, ...)\r\n\r\n\r\n\r\nEn donde:\r\n- X: es un vector o lista.\r\n- FUN: es la función que se aplicará a cada elemento de X. Algunas funciones predefinidas que pueden utilizarse incluyen mean(), median(), sum(), min() y max(). También pueden usarse funciones definidas por el usuario.\r\nEn los siguientes ejemplos, se utiliza lapply() para aplicar diferentes funciones a un vector de nombres de personas.\r\n\r\n\r\nnombres <- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\r\n\r\n# Los nombres de la lista se transforman a minúscula\r\nnombres_en_minuscula <- lapply(nombres, tolower)\r\nnombres_en_minuscula\r\n\r\n\r\n[[1]]\r\n[1] \"andrés\"\r\n\r\n[[2]]\r\n[1] \"beatriz\"\r\n\r\n[[3]]\r\n[1] \"carlos\"\r\n\r\n[[4]]\r\n[1] \"marta\"\r\n\r\n[[5]]\r\n[1] \"pedro\"\r\n\r\n[[6]]\r\n[1] \"sara\"\r\n\r\n# Se genera un saludo para cada nombre\r\nnombres_con_saludo <- lapply(nombres, function(arg1, arg2) paste(arg1, arg2), arg1=\"Hola\")\r\nnombres_con_saludo\r\n\r\n\r\n[[1]]\r\n[1] \"Hola Andrés\"\r\n\r\n[[2]]\r\n[1] \"Hola Beatriz\"\r\n\r\n[[3]]\r\n[1] \"Hola Carlos\"\r\n\r\n[[4]]\r\n[1] \"Hola Marta\"\r\n\r\n[[5]]\r\n[1] \"Hola Pedro\"\r\n\r\n[[6]]\r\n[1] \"Hola Sara\"\r\n\r\ntapply()\r\nLa función tapply() aplica una función a cada nivel de un factor.\r\nLa sintaxis de la función es:\r\n\r\n\r\ntapply(X, INDEX, FUN)\r\n\r\n\r\n\r\nEn donde:\r\n- X: es un objeto, tipicamente un vector.\r\n- INDEX: es una lista que contiene un factor.\r\n- FUN: es la función que se aplicará a cada elemento de X.\r\nEn el siguiente ejemplo, se utiliza tapply() para calcular la mediana del ancho del sépalo para cada especie del conjunto de datos iris.\r\n\r\n\r\ndata(iris)\r\ntapply(iris$Sepal.Width, iris$Species, median)\r\n\r\n\r\n    setosa versicolor  virginica \r\n       3.4        2.8        3.0 \r\n\r\n Ejercicio:\r\na. Utilice la función tapply() para obtener el promedio de las longitudes de los pétalos para cada especie del conjunto de datos iris. \r\nVectorización\r\nEn R, muchas operaciones y funciones pueden ser vectorizadas, lo que significa que pueden aplicarse a los elementos de un vector sin necesidad de iterar uno por uno en estos.\r\nPor ejemplo, considérese el siguiente fragmento de código no vectorizado, que utiliza un ciclo para convertir los números de un vector a sus valores absolutos:\r\n\r\n\r\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\r\n\r\nfor (i in 1:length(vector_numeros)) {\r\n  if (vector_numeros[i] < 0) {\r\n    vector_numeros[i] <- -vector_numeros[i]\r\n  }\r\n}\r\n\r\nvector_numeros\r\n\r\n\r\n[1] 23 17 34  0 12 55\r\n\r\nEl siguiente fragmento de código realiza la misma tarea, pero de forma vectorizada:\r\n\r\n\r\nvector_numeros <- c(23, -17, 34, 0, -12, 55)\r\n\r\n# Se usa una expresión lógica para seleccionar los elementos del vector < 0\r\nnegativos <- vector_numeros < 0\r\nnegativos\r\n\r\n\r\n[1] FALSE  TRUE FALSE FALSE  TRUE FALSE\r\n\r\n# Se cambian los elementos seleccionados en el paso anterior sin utilizar el for\r\nvector_numeros[negativos] <- vector_numeros[negativos] * -1\r\n\r\nvector_numeros\r\n\r\n\r\n[1] 23 17 34  0 12 55\r\n\r\n Ejercicio:\r\na. Utilice código vectorizado para implementar una función que reciba como argumento un vector de números y retorne el mismo vector con los elementos impares (solo los impares) elevados al cuadrado. \r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-17T23:44:16-06:00"
    },
    {
      "path": "leccion-03-rmarkdown.html",
      "title": "R Markdown",
      "author": [],
      "contents": "\r\n\r\nContents\r\nResumen\r\nTrabajo previo\r\nDescripción general\r\nMarkdown\r\nVariaciones\r\nSintaxis\r\nEncabezados\r\nItálicas\r\nNegritas\r\nCitas textuales\r\nEnlaces a otros documentos\r\nImágenes\r\nListas numeradas\r\nListas no numeradas\r\nOtros elementos de sintaxis\r\n\r\n\r\n\r\nResumen\r\nEn esta lección, se introduce el lenguaje de marcas R Markdown.\r\nTrabajo previo\r\nLea los capítulos del 1 al 3 de Xie, Y., Allaire, J., & Grolemund, G. (2018). R Markdown: The Definitive Guide.\r\nTambién se recomienda:\r\nR Markdown (sitio oficial).\r\nYihui Xie | One R Markdown Document, Fourteen Demos | RStudio (2020).\r\nReproducible reports with R Markdown.\r\nReproducible Templates for Analysis and Dissemination.\r\nIntroduction to Blogdown (R Package) | RStudio Webinar - 2017.\r\nSteps to create website with blogdown and the Hugo Academic (Wowchemy) theme.\r\nHow To Hugo Academic.\r\n\r\nDescripción general\r\nR Markdown es un formato de archivo para construir documentos dinámicos con el lenguaje de programación R y el lenguaje de marcado Markdown.\r\nMarkdown\r\nMarkdown es un lenguaje de marcas creado en 2004 por John Gruber. Las “marcas” se utilizan para brindar información acerca de la presentación (ej. negritas, itálicas) o la estructura (ej. títulos, encabezados) de un documento. Se caracteriza por ser más sencillo de leer y de usar que otros lenguajes de marcas (ej. HTML). Los documentos escritos en Markdown pueden exportarse a una gran variedad de formatos (ej. HTML, Doc, PDF, Latex) para ser usados en libros, presentaciones o páginas web, entre otros. Markdown es ampliamente utilizado en comunicación científica, documentación de programas e investigación reproducible.\r\nVariaciones\r\nLas variaciones de Markdown, también llamadas flavors, son extensiones o modificaciones de la especificación original. Entre las más populares están:\r\nR Markdown: para el lenguaje R.\r\nMyST (Markedly Structured Text) Markdown: para Jupyter Book.\r\nGitHub Flavored Markdown: para la plataforma GitHub.\r\nPuede consultarse una lista más extensa en https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors.\r\nSintaxis\r\nLa sintaxis de Markdown permite especificar diferentes componentes de un documento, entre los que están:\r\nEncabezados.\r\nEstilos (ej. negritas, itálicas).\r\nCitas textuales.\r\nEnlaces a otros documentos (ej. páginas web).\r\nImágenes.\r\nListas.\r\nEncabezados\r\nPueden definirse seis niveles de encabezados, con los símbolos de numeral (#) antes del texto. El primer nivel es el más grande y el sexto el más pequeño. A la izquierda se muestra la sintaxis Markdown y a la derecha la forma en que se despliega en un documento.\r\n\r\nItálicas\r\nSe definen con un asterisco (*) antes y después del texto o con un guión bajo (_) antes y después del texto.\r\n\r\nNegritas\r\nSe definen con dos asteriscos (**) antes y después del texto o con dos guiones bajos (__) antes y después del texto.\r\n\r\nCitas textuales\r\nSe definen con un símbolo de “mayor que” (>) antes de cada línea.\r\n\r\nEnlaces a otros documentos\r\nSe definen con un paréntesis cuadrados[] seguidos de paréntesis redondos (). En los paréntesis cuadrados se coloca (opcionalmente) el texto del enlace y en los redondos la dirección del documento.\r\n\r\nImágenes\r\nSe definen con un signo de admiración de cierre (!), paréntesis cuadrados[] y paréntesis redondos (). En los paréntesis cuadrados se coloca (opcionalmente) un texto para la imagen y en los redondos la dirección de la imagen, ya sea en el disco o en la red.\r\n\r\nListas numeradas\r\nSe definen con números antes de cada elemento.\r\n\r\nListas no numeradas\r\nSe definen con guiones antes de cada elemento.\r\n\r\nOtros elementos de sintaxis\r\nPara conocer otros elementos de la sintaxis de Markdown, se recomienda revisar en detalle:\r\nGuía de referencia de Markdown: Markdown Guide\r\nTutorial sobre Markdown: Markdown Tutorial\r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-29T16:40:19-06:00"
    },
    {
      "path": "leccion-04-blogdown.html",
      "title": "blogdown",
      "author": [],
      "contents": "\r\n\r\nContents\r\nResumen\r\nTrabajo previo\r\nDescripción general\r\n\r\nResumen\r\nEn esta lección, se introduce el paquete blogdown para la creación de sitios web mediante R Markdown.\r\nTrabajo previo\r\nLea los capítulos del 1 al 5 de Xie, Y., Thomas, A., & Hill, A. (2017). blogdown: Creating Websites with R Markdown.\r\nTambién se recomienda:\r\nCreate Blogs and Websites with R Markdown - blogdown.\r\nIntroduction to Blogdown (R Package) | RStudio Webinar - 2017.\r\nSteps to create website with blogdown and the Hugo Academic (Wowchemy) theme.\r\nHow To Hugo Academic.\r\n\r\nDescripción general\r\nblogdown es un paquete de R para la creación de sitios web mediante R Markdown. Se apoya en Hugo, un generador de sitios web estáticos.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-08-31T22:15:24-06:00"
    }
  ],
  "collections": []
}
